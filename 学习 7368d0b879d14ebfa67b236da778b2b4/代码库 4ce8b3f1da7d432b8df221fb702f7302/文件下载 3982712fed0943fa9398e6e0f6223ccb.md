# 文件下载

Created: July 29, 2021 5:22 PM
标签: JS, 下载, 代码, 文件

## 1. a标签下载

```jsx
let name = decodeURI('分班示例版本.xlsx')
const blob = new Blob([res.data])
const elink = document.createElement('a')
elink.download = name
elink.style.display = 'none'
elink.href = URL.createObjectURL(blob)
document.body.appendChild(elink)
elink.click()
URL.revokeObjectURL(elink.href)
document.body.removeChild(elink)
```

## 2. `showSaveFilePicker` API 下载

该方法会显示允许用户选择保存路径的文件选择器。

```jsx
let FileSystemFileHandle = Window.showSaveFilePicker(options)
```

- `excludeAcceptAllOption`: 布尔类型，默认值为`false` 。默认情况下，选择器应包含一个不应用任何文件类型过滤器的选项。将此选项设置为`true` ，意味着`types` 选项不可用。
- `types` ：数组类型，表示允许保存的文件类型列表。数组中的每一项是包含以下属性的配置对象。
    - `description(可选)` ：用于描述允许保存文件类型类别。
    - `accept` ：是一个对象，该对象的`key` 是`MIME` 类型，值是文件扩展名列表。

```jsx
async function saveFile(blob, filename) {
	try {
		const handle = await window.showSaveFilePicker({
			suggestedName: filename,
			types: [
				{
					description: "PNG file",
					accept: {
						"img/png": [".png"]
					}
				},
				{
					description: "Jpeg file",
					accept: {
						"image/jpeg": [".jpeg"]
					}
				}
			]
		})
		const writable = await handle.createWritable()
		await writable.write(blob)
		await writable.close()
		return handle
	} catch (err) {
		console.error(err.name, err.message)
	}
}

function download () {
	if (!imgDataUrl) {
		alert("请先合成图片")
		return
	}
	const imgBlob = dataUrlToBlob(imgDataUrl, "image/png")
	saveFile(imgBlob, "face.png")
}
```

## 3. FileSaver.js

引入`FileSaver.js` 这个库，使用`saveAs` 方法来保存文件。

```jsx
fileSaver saveAs(
	Blob/File/Url
	optional DOMString filename
	optional Object { auutoBom }
)
```

支持三个参数

- 第一个参数
    
    支持`Blob/File/Url` 三中类型，
    
- 第二个参数（可选）
    
    表示文件名
    
- 第三个参数（可选）
    
    表示配置对象
    

如果需要`FileSaver.js` 自动提供`Unicode` 文本编码提示，则需要设置`{ autoBom: true }`

例子：

1. 保存文本
    
    ```jsx
    let blob = new Blob(["大家好，我是阿宝哥"], { type: "text/plain;charset=utg-8" })
    saveAs(blob, "hello.txt")
    ```
    
2. 保存线上资源
    
    ```jsx
    saveAs("https://httpbin.org/image", "image.jpg")
    ```
    
    如果下载地址和当前站点是同域的，使用`a[download]` 方式下载。否则，先使用**同步的HEAD请求**判断是否支持**CORS**机制，若支持，将进行数据下载，并使用`Blob URL`实现文件下载。如果不支持，使用`a[download]`方式下载。
    
    标准的`W3C File API Blob` 接口并非在所有浏览器中都可用，可以考虑使用 `Blob.js` 来解决兼容性问题
    
3. 保存 canvas 画布内容
    
    ```jsx
    let canvas = document.getElementById("my-canvas")
    canvas.toBlob(function(blob) {
    	saveAs(blob, "abao.png")
    })
    ```
    
    `canvas.toBlob()` 方法并非在所有浏览器中都可用，考虑使用canvas-toBlob.js 解决兼容性问题
    
4. download方法
    
    ```jsx
    function download () {
    	const imgBlob = dataUrlToBlob(imgDataUrl, "image/png")
    	saveAs(imgBlob, "face.png")
    }
    ```
    

## 4. zip下载

利用 `JSZip` 这个库提供的 `API` 。

```jsx
var JSZip = require('jszip')
var JSZipUtils = require('jszip-utils')

async function download () {
	let zip = new JSZip()
	Promise.all(imageUrls.map(getFileContent)).then((contents) => {
		contents.forEach((content, i) => {
			zip.file(images[i], content)
		})
		zip.generateAsync({ type: "blob" }).then(function (blob) {
			saveAs(blob, "material.zip")
		})
	})
}

// 单个文件下载
zip.file('1.png', this.getFileContent(myUrl))
zip.generateAsync({ type: 'blob' }).then((blob) => {
	this.$saveAs(blob, 'material.zip')
})

// 从指定的url上下载文件内容
function getFileContent(fileUrl) {
	return new JSZip.external.Promise(function (resolve, reject) {
		// 调用jszip-utils库提供的getBinaryContent方法获取文件内容
		JSZipUtils.getBinaryContent(fileUrl, function (err, data) {
			if (err) {
				reject(err)
			} else {
				resolve(data)
			}
		})
	})
}
```